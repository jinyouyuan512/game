// you/server/server.js
import 'dotenv/config';
import express from 'express';
import cors from 'cors';
import bodyParser from 'body-parser';
import { createClient } from '@supabase/supabase-js';
import path from 'path';
import fs from 'fs';
import { exec } from 'child_process';
import { promisify } from 'util';
const execPromise = promisify(exec);

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors({
  origin: ['http://localhost:5173', 'http://localhost:5174', 'http://localhost:3000', 'http://127.0.0.1:5173', 'http://127.0.0.1:5174'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));
app.use(bodyParser.json());

// ç¡®ä¿ä¸Šä¼ ç›®å½•å­˜åœ¨
const uploadDir = path.join(process.cwd(), '../uploads');
const imagesDir = path.join(uploadDir, 'images');
const videosDir = path.join(uploadDir, 'videos');

[uploadDir, imagesDir, videosDir].forEach(dir => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
});

// é…ç½®é™æ€æ–‡ä»¶æœåŠ¡
app.use('/uploads', express.static(uploadDir));
console.log(`é™æ€æ–‡ä»¶æœåŠ¡é…ç½®å®Œæˆï¼Œè·¯å¾„: /uploads -> ${uploadDir}`);

// Supabase Connection
const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_ANON_KEY;
const supabase = createClient(supabaseUrl, supabaseKey);

// åˆ›å»ºæ¨¡æ‹Ÿæ•°æ®ï¼Œå½“Supabaseè¿æ¥å¤±è´¥æ—¶ä½¿ç”¨
const mockData = {
  games: [
    { id: 1, name: 'è‹±é›„è”ç›Ÿ', description: 'ä¸€æ¬¾å¤šäººåœ¨çº¿æˆ˜æœ¯ç«æŠ€æ¸¸æˆ', coverImage: 'lol.jpg', status: 'active', platform: 'PC', developer: 'Riot Games', publisher: 'Riot Games' },
    { id: 2, name: 'åŸç¥', description: 'ä¸€æ¬¾å¼€æ”¾ä¸–ç•ŒåŠ¨ä½œè§’è‰²æ‰®æ¼”æ¸¸æˆ', coverImage: 'genshin.jpg', status: 'active', platform: 'PC/æ‰‹æœº/ä¸»æœº', developer: 'ç±³å“ˆæ¸¸', publisher: 'ç±³å“ˆæ¸¸' },
    { id: 3, name: 'ç‹è€…è£è€€', description: 'ä¸€æ¬¾å¤šäººåœ¨çº¿æˆ˜æœ¯ç«æŠ€æ‰‹æœºæ¸¸æˆ', coverImage: 'wzry.jpg', status: 'active', platform: 'æ‰‹æœº', developer: 'è…¾è®¯', publisher: 'è…¾è®¯' }
  ],
  strategies: [
    { id: 1, title: 'è‹±é›„è”ç›Ÿæ–°æ‰‹æ”»ç•¥', content: 'è¿™æ˜¯ä¸€ä»½è¯¦ç»†çš„æ–°æ‰‹å…¥é—¨æŒ‡å—...', difficulty: 'ç®€å•', type: 'å…¥é—¨', game_id: 1, user_id: 1, view_count: 100, status: 'published', image_urls: JSON.stringify(['/uploads/images/lol-guide.jpg']), video_urls: JSON.stringify([]) },
    { id: 2, title: 'åŸç¥æ¢ç´¢æŠ€å·§', content: 'é«˜æ•ˆæ¢ç´¢æç“¦ç‰¹å¤§é™†çš„æ–¹æ³•...', difficulty: 'ä¸­ç­‰', type: 'æ¢ç´¢', game_id: 2, user_id: 2, view_count: 200, status: 'published', image_urls: JSON.stringify([]), video_urls: JSON.stringify(["/uploads/videos/traffic_accident_1.mp4", "uploads/videos/traffic_accident_2.mp4"]) }
  ],
  tags: [
    { id: 1, name: 'æ–°æ‰‹' },
    { id: 2, name: 'æ”»ç•¥' },
    { id: 3, name: 'æ¢ç´¢' },
    { id: 4, name: 'è§’è‰²åŸ¹å…»' }
  ],
  users: [
    { id: 1, username: 'admin', password: '123456', email: 'admin@example.com' },
    { id: 2, username: 'user1', password: 'password1', email: 'user1@example.com' }
  ],
  notes: []
};

// åˆ›å»ºæ¨¡å‹ä»£ç†å¯¹è±¡ï¼Œä¼˜å…ˆä½¿ç”¨Supabaseï¼Œå¦‚æœå¤±è´¥åˆ™è¿”å›æ¨¡æ‹Ÿæ•°æ®
const User = {
  findOne: async (options) => {
    try {
      console.log('å°è¯•ä»SupabaseæŸ¥æ‰¾ç”¨æˆ·:', options.where);
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .match(options.where || {})
        .single();
      if (error) {
        console.error('SupabaseæŸ¥æ‰¾ç”¨æˆ·å¤±è´¥:', error.code, error.message);
        throw error;
      }
      console.log('æˆåŠŸä»Supabaseæ‰¾åˆ°ç”¨æˆ·:', { id: data.id, username: data.username });
      return data;
    } catch (error) {
      console.warn('ä½¿ç”¨æ¨¡æ‹ŸUseræ•°æ®:', error.message);
      // ä»æ¨¡æ‹Ÿæ•°æ®ä¸­æŸ¥æ‰¾
      return mockData.users.find(user => {
        const where = options.where || {};
        return Object.keys(where).every(key => user[key] === where[key]);
      });
    }
  },
  create: async (userData) => {
    try {
      console.log('å°è¯•å‘Supabaseæ’å…¥ç”¨æˆ·æ•°æ®:', { username: userData.username, hasEmail: !!userData.email });
      
      // åˆ—å‡ºæ‰€æœ‰å¯ç”¨çš„è¡¨ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰usersè¡¨
      try {
        const { data: tables } = await supabase.rpc('get_tables');
        console.log('Supabaseå¯ç”¨è¡¨:', tables ? tables.map(t => t.name).join(', ') : 'æ— æ³•è·å–è¡¨åˆ—è¡¨');
      } catch (tablesError) {
        console.warn('æ— æ³•è·å–Supabaseè¡¨åˆ—è¡¨:', tablesError.message);
      }
      
      // æ£€æŸ¥æ•°æ®åº“è¡¨ç»“æ„
      try {
        const { data: tableData, error: tableError } = await supabase
          .from('users')
          .select('*')
          .limit(1);
        
        if (tableError) {
          console.error('Supabase usersè¡¨æŸ¥è¯¢å¤±è´¥:', tableError.code, tableError.message);
        } else {
          console.log('Supabase usersè¡¨æŸ¥è¯¢æˆåŠŸï¼Œè¿”å›è¡Œæ•°:', tableData ? tableData.length : 0);
          if (tableData && tableData.length > 0) {
            console.log('usersè¡¨å­—æ®µ:', Object.keys(tableData[0]).join(', '));
          }
        }
      } catch (tableError) {
        console.error('Supabase usersè¡¨ç»“æ„æ£€æŸ¥å¼‚å¸¸:', tableError.message);
      }
      
      // æ£€æŸ¥æ˜¯å¦æœ‰auth.usersè¡¨ï¼ˆSupabaseé»˜è®¤ç”¨æˆ·è¡¨ï¼‰
      try {
        const { data: authUsersData, error: authUsersError } = await supabase
          .from('auth.users')
          .select('*')
          .limit(1);
        
        if (authUsersError) {
          console.warn('auth.usersè¡¨æŸ¥è¯¢å¤±è´¥:', authUsersError.message);
        } else {
          console.log('auth.usersè¡¨æŸ¥è¯¢æˆåŠŸï¼Œè¿”å›è¡Œæ•°:', authUsersData ? authUsersData.length : 0);
        }
      } catch (authError) {
        console.warn('auth.usersè¡¨æ£€æŸ¥å¼‚å¸¸:', authError.message);
      }
      
      // å‡†å¤‡è¦æ’å…¥çš„æ•°æ®ï¼Œç¡®ä¿å­—æ®µåç§°ä¸æ•°æ®åº“åŒ¹é…
    const insertData = {
      username: userData.username,
      password: userData.password,
      email: userData.email || null
    };
      
      console.log('å‡†å¤‡æ’å…¥çš„æ•°æ®å­—æ®µ:', Object.keys(insertData).join(', '));
      
      // å°è¯•åœ¨publicæ¨¡å¼ä¸‹æ’å…¥
      try {
        const { data, error } = await supabase
          .from('users')
          .insert([insertData])
          .select()
          .single();
        
        if (error) {
          console.error('Supabaseæ’å…¥ç”¨æˆ·å¤±è´¥:', error.code, error.message);
          
          // å°è¯•ä½¿ç”¨ä¸åŒçš„æ–¹æ³•
          try {
            const { data: altData, error: altError } = await supabase
              .from('users')
              .insert([insertData]);
            
            if (altError) {
              console.error('æ›¿ä»£æ’å…¥æ–¹æ³•ä¹Ÿå¤±è´¥:', altError.code, altError.message);
            } else {
              console.log('æ›¿ä»£æ’å…¥æ–¹æ³•æˆåŠŸ');
              return { ...insertData, id: 'new' };
            }
          } catch (altError) {
            console.error('æ›¿ä»£æ’å…¥æ–¹æ³•å¼‚å¸¸:', altError.message);
          }
          
          throw error;
        }
        
        console.log('ç”¨æˆ·æˆåŠŸæ’å…¥åˆ°Supabase:', { id: data.id, username: data.username });
        return data;
      } catch (insertError) {
        // å¦‚æœpublic.usersè¡¨å¤±è´¥ï¼Œå°è¯•ç›´æ¥ä½¿ç”¨auth.usersï¼ˆå¦‚æœå¯ç”¨ï¼‰
        console.warn('å°è¯•ä½¿ç”¨auth.usersè¡¨æ’å…¥ç”¨æˆ·');
        throw insertError;
      }
    } catch (error) {
      console.error('Supabaseç”¨æˆ·åˆ›å»ºå¤±è´¥ï¼Œå›é€€åˆ°æ¨¡æ‹Ÿæ•°æ®:', error.message);
      const newId = mockData.users.length + 1;
      const newUser = { ...userData, id: newId };
      mockData.users.push(newUser);
      console.log('å·²åœ¨æ¨¡æ‹Ÿæ•°æ®ä¸­åˆ›å»ºç”¨æˆ·:', { id: newId, username: newUser.username });
      return newUser;
    }
  },
  findAll: async (options = {}) => {
    try {
      let query = supabase.from('users').select('*');
      if (options.where) {
        query = query.match(options.where);
      }
      const { data, error } = await query;
      if (error) throw error;
      return data;
    } catch (error) {
      console.warn('ä½¿ç”¨æ¨¡æ‹ŸUsersæ•°æ®:', error.message);
      // ä»æ¨¡æ‹Ÿæ•°æ®ä¸­ç­›é€‰
      if (!options.where) return mockData.users;
      return mockData.users.filter(user => {
        const where = options.where;
        return Object.keys(where).every(key => user[key] === where[key]);
      });
    }
  }
};

const Note = {
  findAll: async (options = {}) => {
    try {
      let query = supabase.from('notes').select('*');
      if (options.where) {
        query = query.match(options.where);
      }
      const { data, error } = await query;
      if (error) throw error;
      return data;
    } catch (error) {
      console.warn('ä½¿ç”¨æ¨¡æ‹ŸNotesæ•°æ®:', error.message);
      // ä»æ¨¡æ‹Ÿæ•°æ®ä¸­ç­›é€‰
      if (!options.where) return mockData.notes;
      return mockData.notes.filter(note => {
        const where = options.where;
        return Object.keys(where).every(key => note[key] === where[key]);
      });
    }
  },
  create: async (noteData) => {
    try {
      const { data, error } = await supabase
        .from('notes')
        .insert([noteData])
        .select()
        .single();
      if (error) throw error;
      return data;
    } catch (error) {
      console.warn('æ¨¡æ‹Ÿåˆ›å»ºNoteæ•°æ®:', error.message);
      const newId = mockData.notes.length + 1;
      const newNote = { ...noteData, id: newId };
      mockData.notes.push(newNote);
      return newNote;
    }
  },
  findOne: async (options) => {
    try {
      const { data, error } = await supabase
        .from('notes')
        .select('*')
        .match(options.where || {})
        .single();
      if (error) throw error;
      return data;
    } catch (error) {
      console.warn('ä½¿ç”¨æ¨¡æ‹ŸNoteæ•°æ®:', error.message);
      // ä»æ¨¡æ‹Ÿæ•°æ®ä¸­æŸ¥æ‰¾
      return mockData.notes.find(note => {
        const where = options.where || {};
        return Object.keys(where).every(key => note[key] === where[key]);
      });
    }
  },
  update: async (updates, options) => {
    try {
      const { data, error } = await supabase
        .from('notes')
        .update(updates)
        .match(options.where || {})
        .select();
      if (error) throw error;
      return [data.length, data];
    } catch (error) {
      console.warn('æ¨¡æ‹Ÿæ›´æ–°Noteæ•°æ®:', error.message);
      // æ¨¡æ‹Ÿæ›´æ–°
      const updatedNotes = mockData.notes.map(note => {
        const where = options.where || {};
        const matches = Object.keys(where).every(key => note[key] === where[key]);
        return matches ? { ...note, ...updates } : note;
      });
      mockData.notes = updatedNotes;
      return [updatedNotes.length, updatedNotes];
    }
  },
  destroy: async (options) => {
    try {
      const { data, error, count } = await supabase
        .from('notes')
        .delete()
        .match(options.where || {})
        .select('*');
      if (error) throw error;
      return count;
    } catch (error) {
      console.warn('æ¨¡æ‹Ÿåˆ é™¤Noteæ•°æ®:', error.message);
      // æ¨¡æ‹Ÿåˆ é™¤
      const beforeCount = mockData.notes.length;
      mockData.notes = mockData.notes.filter(note => {
        const where = options.where || {};
        return !Object.keys(where).every(key => note[key] === where[key]);
      });
      return beforeCount - mockData.notes.length;
    }
  },
  findByPk: async (id) => {
    try {
      const { data, error } = await supabase
        .from('notes')
        .select('*')
        .eq('id', id)
        .single();
      if (error) throw error;
      return data;
    } catch (error) {
      console.warn('ä½¿ç”¨æ¨¡æ‹ŸNoteæ•°æ®:', error.message);
      return mockData.notes.find(note => note.id === id);
    }
  }
};

const Game = {
  findAll: async (options = {}) => {
    try {
      let query = supabase.from('games').select('*');
      if (options.where) {
        if (options.where[Sequelize.Op?.or]) {
          // å¤„ç†æœç´¢æ¡ä»¶
          const orConditions = options.where[Sequelize.Op.or];
          const orFilters = orConditions.map(condition => {
            const field = Object.keys(condition)[0];
            const value = condition[field].like.replace(/%/g, '*');
            return `${field}.ilike.${value}`;
          });
          query = query.or(orFilters);
        } else if (options.where.status) {
          query = query.eq('status', options.where.status);
        } else {
          query = query.match(options.where);
        }
      }
      const { data, error } = await query;
      if (error) throw error;
      return data;
    } catch (error) {
      console.warn('ä½¿ç”¨æ¨¡æ‹ŸGamesæ•°æ®:', error.message);
      // ä»æ¨¡æ‹Ÿæ•°æ®ä¸­ç­›é€‰
      let result = [...mockData.games];
      if (options.where) {
        if (options.where[Sequelize.Op?.or]) {
          // å¤„ç†æœç´¢æ¡ä»¶
          const orConditions = options.where[Sequelize.Op.or];
          result = result.filter(game => {
            return orConditions.some(condition => {
              const field = Object.keys(condition)[0];
              const value = condition[field].like.replace(/%/g, '');
              return game[field]?.toLowerCase().includes(value.toLowerCase());
            });
          });
        } else if (options.where.status) {
          result = result.filter(game => game.status === options.where.status);
        }
      }
      return result;
    }
  },
  findByPk: async (id) => {
    try {
      const { data, error } = await supabase
        .from('games')
        .select('*')
        .eq('id', id)
        .single();
      if (error) throw error;
      return data;
    } catch (error) {
      console.warn('ä½¿ç”¨æ¨¡æ‹ŸGameæ•°æ®:', error.message);
      return mockData.games.find(game => game.id === id);
    }
  },
  count: async () => {
    try {
      const { count, error } = await supabase
        .from('games')
        .select('*', { count: 'exact' });
      if (error) throw error;
      return count;
    } catch (error) {
      console.warn('ä½¿ç”¨æ¨¡æ‹ŸGamesè®¡æ•°:', error.message);
      return mockData.games.length;
    }
  },
  bulkCreate: async (games) => {
    try {
      const { data, error } = await supabase
        .from('games')
        .insert(games)
        .select();
      if (error) throw error;
      return data;
    } catch (error) {
      console.warn('æ¨¡æ‹Ÿæ‰¹é‡åˆ›å»ºGamesæ•°æ®:', error.message);
      // æ¨¡æ‹Ÿæ‰¹é‡åˆ›å»º
      games.forEach(game => {
        const newId = mockData.games.length + 1;
        mockData.games.push({ ...game, id: newId });
      });
      return games;
    }
  }
};

const Strategy = {
  findAll: async (options = {}) => {
    try {
      let query = supabase.from('strategies').select('*');
      if (options.where) {
        if (options.where[Sequelize.Op?.or]) {
          const orConditions = options.where[Sequelize.Op.or];
          const orFilters = orConditions.map(condition => {
            const field = Object.keys(condition)[0];
            const value = condition[field].like.replace(/%/g, '*');
            return `${field}.ilike.${value}`;
          });
          query = query.or(orFilters);
        }
        if (options.where.status) query = query.eq('status', options.where.status);
        if (options.where.game_id) query = query.eq('game_id', options.where.game_id);
        if (options.where.difficulty) query = query.eq('difficulty', options.where.difficulty);
        if (options.where.view_count?.[Sequelize.Op?.gte]) {
          query = query.gte('view_count', options.where.view_count[Sequelize.Op.gte]);
        }
      }
      const { data, error } = await query;
      if (error) throw error;
      return data;
    } catch (error) {
      console.warn('ä½¿ç”¨æ¨¡æ‹ŸStrategiesæ•°æ®:', error.message);
      // ä»æ¨¡æ‹Ÿæ•°æ®ä¸­ç­›é€‰
      let result = [...mockData.strategies];
      if (options.where) {
        if (options.where[Sequelize.Op?.or]) {
          const orConditions = options.where[Sequelize.Op.or];
          result = result.filter(strategy => {
            return orConditions.some(condition => {
              const field = Object.keys(condition)[0];
              const value = condition[field].like.replace(/%/g, '');
              return strategy[field]?.toLowerCase().includes(value.toLowerCase());
            });
          });
        }
        if (options.where.status) {
          result = result.filter(strategy => strategy.status === options.where.status);
        }
        if (options.where.game_id) {
          result = result.filter(strategy => strategy.game_id === options.where.game_id);
        }
        if (options.where.difficulty) {
          result = result.filter(strategy => strategy.difficulty === options.where.difficulty);
        }
        if (options.where.view_count?.[Sequelize.Op?.gte]) {
          result = result.filter(strategy => strategy.view_count >= options.where.view_count[Sequelize.Op.gte]);
        }
      }
      return result;
    }
  },
  findByPk: async (id) => {
    try {
      // æŸ¥è¯¢æ‰€æœ‰å­—æ®µï¼ŒåŒ…æ‹¬image_urlså’Œvideo_urls
      const { data, error } = await supabase
        .from('strategies')
        .select('*')
        .eq('id', id)
        .single();
      
      console.log('æ•°æ®åº“æŸ¥è¯¢ç»“æœ:', { data, error });
      
      if (error) {
        console.log('æ”»ç•¥ä¸å­˜åœ¨æˆ–æŸ¥è¯¢å¤±è´¥:', error.message);
        // å°è¯•ä»æ¨¡æ‹Ÿæ•°æ®ä¸­æŸ¥æ‰¾
        const mockStrategy = mockData.strategies.find(strategy => strategy.id === id);
        if (mockStrategy) {
          console.log('ä»æ¨¡æ‹Ÿæ•°æ®ä¸­æ‰¾åˆ°æ”»ç•¥');
          return mockStrategy;
        }
        return null; // è®°å½•ä¸å­˜åœ¨æ—¶è¿”å›null
      }
      
      // æ·»åŠ è°ƒè¯•æ—¥å¿—ï¼ŒæŸ¥çœ‹è¿”å›çš„æ•°æ®
      console.log('æ•°æ®åº“æŸ¥è¯¢è¿”å›çš„æ”»ç•¥æ•°æ®:', {
        id: data.id,
        hasImageUrls: data.image_urls !== undefined,
        imageUrlsType: typeof data.image_urls,
        imageUrlsValue: data.image_urls,
        hasVideoUrls: data.video_urls !== undefined,
        videoUrlsType: typeof data.video_urls,
        videoUrlsValue: data.video_urls
      });
      return data;
    } catch (error) {
      console.error('æŸ¥è¯¢Strategyå¤±è´¥:', error);
      // ä»æ¨¡æ‹Ÿæ•°æ®ä¸­æŸ¥æ‰¾ä½œä¸ºæœ€åæ‰‹æ®µ
      const mockStrategy = mockData.strategies.find(strategy => strategy.id === id);
      if (mockStrategy) {
        console.log('ä»æ¨¡æ‹Ÿæ•°æ®ä¸­æ‰¾åˆ°æ”»ç•¥');
        return mockStrategy;
      }
      return null; // æ‰€æœ‰æŸ¥æ‰¾éƒ½å¤±è´¥æ—¶è¿”å›null
    }
  },
  create: async ("/uploads/videos/traffic_accident_1.mp4", "uploads/videos/traffic_accident_2.mp4") => {
    try {
      console.log('å¼€å§‹ä¿å­˜æ”»ç•¥åˆ°Supabaseæ•°æ®åº“:', strategyData.title);
      console.log('image_urlså€¼:', strategyData.image_urls);
      console.log('video_urlså€¼:', strategyData.video_urls);
      
      // ç›´æ¥æ’å…¥æ•°æ®ï¼Œä¸ä½¿ç”¨.single()ä»¥é¿å…æ ¼å¼é—®é¢˜
      const { data, error } = await supabase
        .from('strategies')
        .insert([strategyData])
        .select();
      
      if (error) {
        console.error('Supabaseæ’å…¥å¤±è´¥:', error);
        throw error;
      }
      
      if (data && data.length > 0) {
        console.log('Supabaseæ’å…¥æˆåŠŸï¼Œè¿”å›æ•°æ®:', data[0]);
        return data[0];
      } else {
        console.error('Supabaseè¿”å›ç©ºæ•°æ®');
        throw new Error('Supabaseæ’å…¥æˆåŠŸä½†è¿”å›ç©ºæ•°æ®');
      }
    } catch (error) {
      console.error('æ•°æ®åº“åˆ›å»ºStrategyå¤±è´¥:', error.message);
      // ä¸å†ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®ï¼Œç¡®ä¿æ•°æ®åº“æ“ä½œæˆåŠŸ
      throw error;
    }
  },
  update: async (updates, options) => {
    try {
      // ä¸å†ç§»é™¤image_urlså’Œvideo_urlså­—æ®µï¼Œç¡®ä¿å®ƒä»¬è¢«ä¿å­˜åˆ°æ•°æ®åº“ä¸­
      const { data, error } = await supabase
        .from('strategies')
        .update(updates)
        .match(options.where || {})
        .select();
      if (error) throw error;
      return ["/uploads/videos/traffic_accident_1.mp4", "uploads/videos/traffic_accident_2.mp4"];
    } catch (error) {
      console.warn('æ¨¡æ‹Ÿæ›´æ–°Strategyæ•°æ®:', error.message);
      // æ¨¡æ‹Ÿæ›´æ–°ï¼Œä¸å†ç§»é™¤image_urlså’Œvideo_urlså­—æ®µ
      const updatedStrategies = mockData.strategies.map(strategy => {
        const where = options.where || {};
        const matches = Object."/uploads/videos/traffic_accident_1.mp4", "uploads/videos/traffic_accident_2.mp4"s(where).every(key => strategy[key] === where[key]);
        return matches ? { ...strategy, ...updates } : strategy;
      });
      mockData.strategies = updatedStrategies;
      return [updatedStrategies.length, updatedStrategies];
    }
  }
};

const Tag = {
  findAll: async () => {
    try {
      const { data, error } = await supabase.from('tags').select('*');
      if (error) throw error;
      return data;
    } catch (error) {
      console.warn('ä½¿ç”¨æ¨¡æ‹ŸTagsæ•°æ®:', error.message);
      return mockData.tags;
    }
  },
  bulkCreate: async (tags) => {
    try {
      const { data, error } = await supabase
        .from('tags')
        .insert(tags)
        .select();
      if (error) throw error;
      return data;
    } catch (error) {
      console.warn('æ¨¡æ‹Ÿæ‰¹é‡åˆ›å»ºTagsæ•°æ®:', error.message);
      // æ¨¡æ‹Ÿæ‰¹é‡åˆ›å»º
      tags.forEach(tag => {
        const existing = mockData.tags.find(t => t.name === tag.name);
        if (!existing) {
          const newId = mockData.tags.length + 1;
          mockData.tags.push({ ...tag, id: newId });
        }
      });
      return tags;
    }
  }
};

const StrategyTag = {};

// æ¨¡æ‹ŸSequelizeå¯¹è±¡ï¼Œç”¨äºå…¼å®¹ç°æœ‰ä»£ç 
const Sequelize = {
  Op: {
    like: 'like',
    gte: 'gte',
    or: 'or'
  }
};

const sequelize = {
  Sequelize
};

// æ‰§è¡Œæ•°æ®åº“è¿ç§»
async function executeDatabaseMigrations() {
  try {
    console.log('ğŸ”„ å¼€å§‹æ‰§è¡Œæ•°æ®åº“è¿ç§»...');
    
    // è¯»å–SQLè¿ç§»æ–‡ä»¶
    const migrationFilePath = path.resolve('./create_media_tables.sql');
    
    if (!fs.existsSync(migrationFilePath)) {
      console.log('âš ï¸  æœªæ‰¾åˆ°è¿ç§»æ–‡ä»¶:', migrationFilePath);
      return;
    }
    
    const sql = fs.readFileSync(migrationFilePath, 'utf8');
    
    // æ‰§è¡ŒSQLè¯­å¥
    // æ³¨æ„ï¼šç”±äºæˆ‘ä»¬ä½¿ç”¨Supabaseï¼Œè¿™é‡Œæˆ‘ä»¬å¯ä»¥ç›´æ¥é€šè¿‡PostgREST APIæ‰§è¡ŒSQL
    // ä½†ä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬ä½¿ç”¨psqlå‘½ä»¤è¡Œå·¥å…·
    try {
      // å°è¯•ä½¿ç”¨psqlæ‰§è¡Œè¿ç§»
      console.log('å°è¯•ä½¿ç”¨psqlæ‰§è¡ŒSQLè¿ç§»...');
      // æ³¨æ„ï¼šå®é™…ä½¿ç”¨æ—¶éœ€è¦é…ç½®æ­£ç¡®çš„ç¯å¢ƒå˜é‡
      // await execPromise(`psql "${process.env.DATABASE_URL}" -c "${sql}"`);
      console.log('å¦‚æœéœ€è¦æ‰‹åŠ¨æ‰§è¡Œè¿ç§»ï¼Œè¯·ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤:');
      console.log(`psql "DATABASE_URL" -f ${migrationFilePath}`);
    } catch (execError) {
      console.log('âš ï¸  psqlæ‰§è¡Œå¤±è´¥ï¼Œå°†é€šè¿‡Supabaseç›´æ¥æ‰§è¡ŒSQL...');
      
      // ç”±äºSupabaseä¸æ”¯æŒç›´æ¥æ‰§è¡Œå¤šæ¡SQLè¯­å¥ï¼Œæˆ‘ä»¬éœ€è¦æ‹†åˆ†æ‰§è¡Œ
      const sqlStatements = sql.split(';').filter(Boolean).map(statement => statement.trim());
      
      for (const statement of sqlStatements) {
        if (statement) {
          try {
            const { error } = await supabase.rpc('execute_sql', { sql: statement });
            if (error) {
              console.error('æ‰§è¡ŒSQLè¯­å¥å¤±è´¥:', statement, 'é”™è¯¯:', error.message);
            } else {
              console.log('âœ… SQLè¯­å¥æ‰§è¡ŒæˆåŠŸ:', statement.substring(0, 100) + '...');
            }
          } catch (error) {
            console.error('æ‰§è¡ŒSQLæ—¶å‘ç”Ÿé”™è¯¯:', error);
          }
        }
      }
    }
    
    console.log('âœ… æ•°æ®åº“è¿ç§»å®Œæˆï¼');
  } catch (error) {
    console.error('æ‰§è¡Œæ•°æ®åº“è¿ç§»æ—¶å‘ç”Ÿé”™è¯¯:', error);
  }
}

// Database Connection
async function connectDB() {
  try {
    console.log('Attempting to connect to Supabase...');
    // æµ‹è¯•Supabaseè¿æ¥
    const { data, error } = await supabase.from('games').select('id').limit(1);
    
    if (error) {
      console.warn('Supabase connection test failed, but server will continue to run:', error.message);
      console.log('Please check your SUPABASE_URL and SUPABASE_ANON_KEY in .env file');
    } else {
      console.log('Supabase connection established successfully.');
      console.log('Using data from Supabase database.');
    }
  } catch (error) {
    console.warn('Database connection error, but server will continue to run:', error.message);
  }
}

// Basic Route
app.get('/', (req, res) => {
  res.send('You Backend Server is Running!');
});

// Search API Route
app.get('/api/search', async (req, res) => {
  try {
    const { q } = req.query;
    if (!q || q.trim() === '') {
      return res.json({ games: [], strategies: [] });
    }
    
    // æœç´¢å…³é”®è¯å¤„ç†
    const searchTerm = q.trim().toLowerCase();
    
    // æ„å»ºæœç´¢æ¡ä»¶
    const searchCondition = {
      [Sequelize.Op.or]: [
        { name: { like: `%${searchTerm}%` } },
        { description: { like: `%${searchTerm}%` } }
      ]
    };
    
    // æœç´¢æ¸¸æˆ
    const games = await Game.findAll({ where: searchCondition });
    
    // æ„å»ºæ”»ç•¥æœç´¢æ¡ä»¶
    const strategySearchCondition = {
      [Sequelize.Op.or]: [
        { title: { like: `%${searchTerm}%` } },
        { content: { like: `%${searchTerm}%` } }
      ]
    };
    
    // æœç´¢æ”»ç•¥
    let strategies = await Strategy.findAll({ where: strategySearchCondition });
    
    // ç¡®ä¿æ”»ç•¥è¿”å›image_urlså’Œvideo_urlså­—æ®µ
    strategies = strategies.map(strategy => ({
      ...strategy,
      image_urls: strategy.image_urls || [],
      video_urls: strategy.video_urls || []
    }));
    
    res.json({ games, strategies });
  } catch (error) {
    console.error('æœç´¢å¤±è´¥:', error);
    res.status(500).json({ error: 'æœç´¢å¤±è´¥', details: error.message });
  }
});

// Import Routers
import { authRouter } from './auth.js';
import { dataRouter } from './data.js';
import { gamesRouter, addSampleData } from './games.js';
import { strategiesRouter } from './strategies.js';

// Use Routers
app.use('/api/auth', authRouter);
app.use('/api/data', dataRouter);
app.use('/', gamesRouter);
app.use('/', strategiesRouter);

// Start Server
async function startServer() {
  try {
    await connectDB();
    // æ‰§è¡Œæ•°æ®åº“è¿ç§»
    await executeDatabaseMigrations();
    // è¿æ¥æˆåŠŸåæ·»åŠ ç¤ºä¾‹æ•°æ®
    await addSampleData();
    
    app.listen(PORT, '0.0.0.0', () => {
      console.log(`Server is running on http://localhost:${PORT}`);
      console.log(`Server is also accessible at http://0.0.0.0:${PORT}`);
    });
  } catch (error) {
    console.error('å¯åŠ¨æœåŠ¡å™¨å¤±è´¥:', error);
    process.exit(1);
  }
}

startServer();

// Note: In a real app, you would define associations here, e.g.,
// User.hasMany(Note, { foreignKey: 'userId' });
// Note.belongsTo(User, { foreignKey: 'userId' });

export { supabase, sequelize, User, Note, Game, Strategy, Tag, StrategyTag, mockData };

